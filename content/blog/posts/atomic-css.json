{
  "title": "CSS Atómico: una fábula acerca de mantener sistemas de diseño en aplicaciones web grandes",
  "draft": false,
  "date": "2019-03-16T09:20:00+01:00",
  "body": "Escribir una aplicación web sin ningún _framework_ de CSS puede ser complicado, sino imposible. El lenguaje es infame por necesitar infinitos trucos y mostrarse de forma poco consistente en distintos dispositivos y navegadores.\n\n<blockquote class=\"twitter-tweet\" data-lang=\"es\"><p lang=\"en\" dir=\"ltr\">The div that looks different in every browser <a href=\"https://t.co/hXmxoLA8fW\">https://t.co/hXmxoLA8fW</a> <a href=\"https://t.co/DTyOKxjhSG\">pic.twitter.com/DTyOKxjhSG</a></p>&mdash; Martijn Cuppens (@Martijn_Cuppens) <a href=\"https://twitter.com/Martijn_Cuppens/status/1015169981368225793?ref_src=twsrc%5Etfw\">6 de julio de 2018</a></blockquote>\n\nEs por ello que surgieron _frameworks_ de a montones como [Bootstrap], [Foundation], [Materialize] y otros.\n\n[Bootstrap]: https://getbootstrap.com/\n[Foundation]: https://foundation.zurb.com/\n[Materialize]: https://materializecss.com/\n\n## El CSS de bootstrap, o CSS basado en componentes\n\nEstos frameworks de “configuración cero” sobreescriben algunos de los tan odiados “estilos por defecto” del navegador, en aspectos como el color de los links, las tipografías y los campos de texto.\n\nPero también nos aportan con la posibilidad de aplicar estilos personalizados para tener “de la nada” botones, campos de texto, barras de navegación, pestañas, _pop-ups_ y componentes similares.\n\nEstos frameworks incluso cuentan con pequeñas librerías JS que proveen funcionalidad dinámica a los componentes, como pueden ser barras de navegación responsivas, *tooltips*, etc.\n\n![Búsqueda en google de \"Bootstrap sites all look the same\"](/img/uploads/capture.png)\n\nSin embargo, como consta con los más de 32K resultados en Google a la frase “Todos los sitios con Bootstrap se ven iguales”, este enfoque “cero configuración” y enfocado a los componentes pronto generó una web llena de sitios idénticos.\n\nCrear componentes nuevos usando uno de estos frameworks, manteniendo un estilo consistente, resultó ser casi imposible sin agregar muchísimo CSS nuevo.\n\nY como cualquiera que haya mantenido un proyecto lo suficientemente grande sabe, **el mejor CSS es el que nunca se escribe**.\\*\n\n_\\* Frase que hace referencia a lo difícil que es mantener, extender y _refactorizar_ el código CSS luego de que haya sido usado en varias pantallas._\n\nAsí nació una forma distinta de escribir CSS, especialmente orientada para aplicaciones webs y grandes sitios: el **CSS atómico**.\n\n## El paradigma del CSS Atómico\n\nEl CSS Atómico consiste en clases que se encargan de una única función, y sólo una. Estas clases son como los átomos de una molécula, porque se pueden usar en infinitas combinaciones para obtener todo tipo de “materiales”.\n\n``` css\n.text-center { text-align: center }\n.pl-2 { padding-left: 0.5rem }\n.pr-2 { padding-right: 0.5rem }\n.px-2 { padding-right: 0.5rem; padding-left: 0.5rem }\n```\n\n*Ejemplo de clases en CSS atómico.*\n\nAl usar *framework* de CSS atómico, ya no se trata de utilizar los componentes pre-definidos (que se ven iguales en todos los sitios y son difíciles de personalizar), sino de crear tus propios componentes apoyándote de las **clases utilitarias** provistas.\n\n**¡Y en qué se diferencian las clases utilitarias del CSS en línea?** (Esta fue la pregunta de muchos cuando recién surgían librerías como [Tachyons] o [BassCss], las primeras librerías que usaban CSS Atómico, cuando el concepto todavía era un *buzzword*).\n\n[Tachyons]: https://tachyons.io/\n[BassCss]: http://basscss.com/\n\nPues, para empezar, el código es más limpio y menos verborrágico.\n\n``` html\n<h1 class=\"mx-2\"></h1>\n<h1 style=\"margin-right: 0.5rem; margin-left: 0.5rem\"></h1>\n```\n\n*¿Cuál de las dos líneas es más fácil de entender?*\n\nPero además, promueve una mayor **consistencia**, ya que nos permite mantener en un único sitio las escalas de la tipografía, los márgenes y *paddings*, así como los colores, el ancho de los bordes, las sombras, etc.\n\nA la hora de cambiar el valor de una tipografía o color, es mucho más fácil cambiar estas líneas...\n\n``` css\n.text-red { color: #... }\n.bg-red { background-color: #... }\n.border-red { border-color: #... }\n```\n\n...a cambiar el valor hexadecimal a lo largo de todo el HTML, o de todos los componentes CSS que utilicen este valor.\n\nOtra ventaja evidente es el uso de clases para ciertos *media querys*, o para ciertos estados como *hover*, *focus*, *active*, etc. Estos estados son imposibles de alcanzar con el CSS en línea.\n\n> También existen *frameworks* como [Teutonic] que cuentan con algunos componentes “opinionados”, pero también con clases utilitarias, intentan brindar lo mejor de los dos mundos.\n\n[Teutonic]: https://teutonic.co/\n\n## Nuevos desafíos\n\nSi bien el CSS atómico brindó muchas soluciones, también trajo algunos problemas.\n\nUno de los problemas de las primeras librerías de CSS atómico era el bajo nivel de personalización que traían. Al usar uno de estos *frameworks* se hereda una paleta de colores y tipografías que luego puede resultar tedioso de sobre-escribir.\n\nPara esto surgieron *frameworks* más avanzados, siendo [Tailwind] el más conocido. Pero Tailwind es más que un *framework*: es **un motor para crear sistemas de diseño**.\n\n[Tailwind]: https://tailwindcss.com/docs/what-is-tailwind/\n\nEn la superficie, Tailwind es un *framework* de CSS atómico “cero configuración” similar a Tachyons o BassCss, pero con la ventaja añadida de que se puede configurar utilizando JavaScript y **puedes compilar tu propia versión del framework**.\n\nEl compilador de Tailwind funciona con NodeJS y se puede integrar con otras herramientas de desarrollo como Webpack, Gulp, Grunt, etc. Permite configurar las variables que se usarán para generar las clases atómicas, tales como: colores, tipografías, escalas de márgenes y *paddings*, límite de los *media querys*, y muchas otras.\n\nPor ejemplo: al cambiar un color el archivo de configuración de Tailwind en tu proyecto, **el compilador generará automáticamente todas las variantes**, incluyendo *media querys*, estados *active*, *hover* y *focus*, etcétera. Pero incluso se puede editar el nombre y la cantidad de *media querys* que quieres para cada utilidad.\n\nYa sea con librerías de CSS atómico como Tachyons, o usando herramientas más configurables como Tailwind, se puede llegar mucho más lejos sin que tu sitio parezca a los demás, y, además, **manteniendo tu sistema de diseño fácil de mantener, extender y modificar**."
}