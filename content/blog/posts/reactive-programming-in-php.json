{
  "title": "Why use Single-File Components also in the Server (or Why I'm building \"React in PHP\")",
  "draft": true,
  "date": "2019-11-30T01:35:48.284Z",
  "body": "A component is an isolated module that can contain business logic, presentation logic and can accept arguments (props).\n\nIf a Component is written in a single file, and it doesn't have sub-components, it could be a standalone application by itself.\n\nReusing components is much easier than reusing the logic, views and models when they are separated in different files and entry-points in the application's structure.\n\nIf you wan't to reuse a component, you simply call it from another.\n\nSince each component has it's own Models, Views and c\nControllers (conveniently renames State, \"render function\" and Methods), reusing them is very easy, and it's also really easy to _reason_ about them.\n\n## The \"Component-Based Paradigm\" for Server-Side Frameworks\n\n> Note: \"Component-Based\" is also used to describe a modular approach to build software.\\\n> In this article, **Component** will refer exclusively to **an entity with State, Methods and the ability to render a View**.\\\n> I use the word \"Component\" with Title Case to differentiate it from \"controller\".\n\nAfter doing some research, I couldn't find anything like the \"single-file components\" approach that frameworks like React and VueJS have that could be implemented using a server-side language.\n\nBut most importantly for me was understanding why I found that idea so desirable. Let's examine the different approaches a little bit...\n\n### \"Controller-Based\" vs. \"Component-Based\"\n\nTraditional PHP applications (let's think of a Laravel app, for example) have this flow:\n\n[![Traditional Controller Based App. Click to open in Google Docs.](/img/uploads/traditional-controller-based-applications.svg \"Click to open in Google Docs.\")](https://docs.google.com/drawings/d/1Uos0VjQ89bd3p_FkjzqoDL6gLCpkdtOhZ5A0LyErv_0/edit?usp=sharing \"Click to view in Google Docs\")\n\n1. Controllers handle everything from rendering views to processing events like form submissions.\n2. Views and controllers are in different folders. The same view can be rendered by different controllers with different data.\n3. The same controller can handle events from different views.\n\nThis architecture is fine until we have the same form in different views or we have more than one form, or action, in the same view. Then it can became a little bit difficult to reason about.\n\nThis is how a view with three forms and a search input could look like:\n\n[![Controller-Based App with three forms and a search/filter form.](/img/uploads/controller-based-app-with-three-forms-and-a-search_filter-form.svg)](https://docs.google.com/drawings/d/1_9zcFBMCkT11p9JutJnHKp18r_MLlqBqyHIH7wMlpJQ/edit?usp=sharing \"Click to view in Google Docs\")\n\n**What would happen if we wanted to use a view, like \"CreateUserForm\", in another view?**\n\nWhen using the form in multiple views, it creates the need to use dinamic redirect rules to keep the logic of the controller DRY.\n\nIt's not a big issue, but it's also something difficult to trace or reason about and adds complexity.\n\n**What other problems this approach has?**\n\nNote that in the example above, the event \"`searchForm`->`onSubmit`\", goes to the same controller as `UserGetIndexController`.\n\nIt's very common to have the logic to filter models in the same controller that renders the view where the controllers are shown.\n\nThis innocent violation of the Single Responsibilty Principle is mostly due to the fact that is very difficult to reason and mantain code in wich the same View is rendered by two different Controllers. Also it conviniently makes the filter params available in the route as GET params.\n\n### What if there was a better way?\n\nThis is the complex app above, but with a \"Component-Based\" approach:\n\n[![Complex App in Reactive Programming](/img/uploads/complex-app-in-reactive-programming.svg)](https://docs.google.com/drawings/d/1G3R-HFbfgzvnhTIKNWNq_vZMuEz-ODebQw1-VkEkcQ8/edit?usp=sharing \"Click to open in Google Draw\")\n\nIn the Component-Based app, each sub-component contains the logic to mutate the global state (the Database in this case, but it might as well be a Cookie, a Session variable, or Query Params). This logic is called **the Component's Method**.\n\nYou might have noticed some things in this approach:\n\n* The architecture of the app is now radically more simple than before (a single controller is used)\n* Each individual Component is now reusable in other controllers, without adding redirections or any other kind of change in the controller itself.\n* The internal methods of the Component could be refactored to mutate the state in a different way, or show data differently, without altering the code of other Components, or controllers.\n* **Application's flow is easier to reason about**\n\n## How a Component-Based Framework could look like in PHP\n\nIn a server-side language like PHP, a Reactive Framework needs to solve extra challenges and limitations (or features, deppends on how you want to see it):\n\n1. **Imposible to use \"disposable\" state**: every state change must be persisted (session storage, database, cookies, query param, etc...). A page refresh wouldn't mean a \"state reset\".\n2. **Each method call consists of a page refresh**: The beauty of JavaScript, where page refreshes are avoided, would not work here. We want to implement the approach 100% server-side, wich means our app would work without any JavaScript. But so many refreshes could break the browser navigation.\n3. **No \"local\" state**: Every state variable must be persisted to some \"gobal\" cache, since a page refresh means any file-levle variables will be re-declared the next time the script executes.\n\n## Demo framework\n\nSo, let's jump right out to some code samples. I hacked a simple library to render components in PHP. I called it `RHR`, which stands for `RHR Hypertext React`. Very original, huh?\n\nThis is what a component looks like in RHReact:\n\n```php\n# /Components/MyComponent.php\n<?php\n\nnamespace Components;\n\nuse RHReact\\Component;\nuse RHReact\\State;\n\nclass MyComponent extends Component {\n\n    function __construct()\n    {\n        $this->state = new State([\n            'counter' => $_SESSION['counter'] ?? 0\n        ]);\n    }\n\n    function increment(): void\n    {\n        $_SESSION['counter']++;\n    }\n\n    function render(): void\n    {\n        ?>\n        <h1><?= $this->state->get('counter') ?></h1>\n\n        <a href=\"<?= $this->methodLink('increment') ?>\">\n            Increment number by one\n        </a>\n        <?php\n    }\n\n}\n```\n\nThe component is loaded in the page like this:\n\n```php\n#/index.php\n<?php\n\nsession_start();\n\nrequire \"vendor/autoload.php\";\n\n\\RHReact\\UI::boot(\\Components\\MyComponent::class);\n```\n\nThis is how it looks like (in the recording I was also experimenting with state mutations using forms, but I won't cover that here)\n\n<blockquote class=\"twitter-tweet\"><p lang=\"und\" dir=\"ltr\"><a href=\"https://t.co/vy8mSxypPu\">pic.twitter.com/vy8mSxypPu</a></p>&mdash; Francisco Brusa (@FranCanoBr) <a href=\"https://twitter.com/FranCanoBr/status/1200614131134394369?ref_src=twsrc%5Etfw\">November 30, 2019</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nIn the back, the `$this->methodLink()` method prints a link that refreshes the page and contains information for the controller to know it has to execute certain logic (specifically, the `increment` method).\n\nThe new page receives some params using a GET request that looks like this:\n\n`GET /?_c=MyComponent&_m=increment`\n\n`RHReact` then looks for this query params and executes the method. After that, it makes a redirect back to the original page (the redirect is needed for the same reason that in a traditional Controller-Based app, to \"clean\" the query params from the user's address bar, and prevent a page refresh to re-trigger the method).\n\n## What's next?\n\n`RHReact` still doesn't support any kind of Component inheritance, nor something similar to React's hooks.\n\nIt's so experimental, it can't even be installed in a subfolder yet. Still, if you wanna use it to do experiments, you can [find the source code in GitHub](https://github.com/AeonFr/RHReact).\n\nThe Component-Based approach to programming still has to solve a lot of problems before proving itself useful in the server-side. Think of things like:\n\n* Middlewares\n* Error handling\n* Shared logic between components\n* Integration with existing frameworks (Laravel, Ruby on Rails, etc.)\n\nA Component-Based Framework for a server-side language would need to address this issues and prove itself better than a \"Controller-Based architecture\" such as the one of Laravel.\n\nI will continue developing `RHReact` (would probably get a new name, though) to see if it can be more than a simple experiment and actually prove itself useful."
}