{
  "title": "Reactive programming in PHP",
  "draft": true,
  "date": "2019-11-30T01:35:48.284Z",
  "body": "As I was taking the [2019 State of Javascript Survey](https://stateofjs.com/), one of the questions triggered an unusual idea...\n\n> Patterns: How do you prefer writing code:\n>\n> * Object-Oriented Programming \n> * Functional Programming\n> * Reactive Programming\n\nThis question revealed an interesting underlying assumptiom, something I knew by heart but hadn't been quite articulated yet: that Reactive Programming is a new paradigm for building apps.\n\nReactive applications can either be written using Object-Oriented syntax or functions, but what's different about them is the concept of the **component**.\n\nA component is an isolated module that can contain business logic, presentation logic and can accept arguments (props).\n\nEach component might as well be a standalone and functional application, only dependant of the child components it contains.\n\nFor example, a form component might be shown within a page with three forms of taking up the hole page. The same component can be reused without hasle and without duplicating code or logic.\n\n## PHP and Reactive Programming\n\nIf Reactive Programming was a new approach to build apps, why was it only used in JavaScript?\n\nTraditional PHP applications (let's think of a Laravel app, for example) have this flow:\n\n1. Controller receives Request, then shows View\n2. View has a form, user submits form.\n3. Controller process form, data updates, Controller sends redirect (go back to 1. but whith updated data in the DB)\n\nThis is a very succesfull approach, it indeed works in very large applications. But it doesn't align very good with the way of thinking of the developer. This is how the application could be schematized:\n\n[![Traditional Controller Based App. Click to open in Google Docs.](/img/uploads/traditional-controller-based-applications.svg \"Click to open in Google Docs.\")](https://docs.google.com/drawings/d/1Uos0VjQ89bd3p_FkjzqoDL6gLCpkdtOhZ5A0LyErv_0/edit?usp=sharing \"Click to view in Google Docs\")\n\nThis architecture is fine until we have the same form in different views or we have more than one form, or action, in the same view.\n\nWhen using the form in multiple views, it creates the need to use dinamic redirect rules. It's not a big issue, but it's also something difficult to trace or reason about and adds complexity.\n\nWhen more than one form, or action, is available in the same view, it creates a lot of controllers that are related to the same view, but are not encapsulated in any obvious way. If you combine this with the need to use the same form in various views, it creates a view that's difficult to reuse and difficult to reason about.\n\nTipically, for simple filter actions, the same controller that renders the view has the logic to do the filtering and return it. This violates the Single Responsibility Principle, but it helps in making the app easier to reason about.\n\nThis is how a view with three forms and a search input could look like:\n\n[![Controller-Based App with three forms and a search/filter form.](/img/uploads/controller-based-app-with-three-forms-and-a-search_filter-form.svg)](https://docs.google.com/drawings/d/1_9zcFBMCkT11p9JutJnHKp18r_MLlqBqyHIH7wMlpJQ/edit?usp=sharing \"Click to view in Google Docs\")\n\nWhat if there was a better way?\n\nThis is the complex app above, but in a component based approach:\n\n[![Complex App in Reactive Programming](/img/uploads/complex-app-in-reactive-programming.svg)](https://docs.google.com/drawings/d/1G3R-HFbfgzvnhTIKNWNq_vZMuEz-ODebQw1-VkEkcQ8/edit?usp=sharing \"Click to open in Google Draw\")\n\nIn the Reactive Programming app, each sub-component contains the logic to mutate the global state (the Database in this case, but it might as well be a Cookie, a Session variable, or Query Params).\n\nA single Controller is needed, every method call is then handled by the Controller by exploring the *Component Three* and finding the method it should execute.\n\nYou might have noticed some things in this approach:\n\n- The architecture of the app is now radically more simple than before\n- Each individual Component is now reusable in other Controllers, without adding redirections or any other kind of change in the Controller itself.\n- **Application's flow is easier to reason about**\n\n## How working in a Reactive Framework could look like in PHP\n\nIn a server-side language like PHP, a Reactive Framework would have to solve some extra challenges and limitations (or features, deppends on how you want to see it):\n\n1. **Imposible to use \"disposable\" state**: every state change must be persisted (session storage, database, cookies, query param, etc...) and wouldn't be \"rolled back\" when refreshing the page.\n2. **Each method consists of a page refresh**: Since the methods would actually be called using a POST or GET request, the page would need to be refreshed. Behind the scenes the framework would excecute the method and then redirect back to the original controller. I will explain this better below.\n3. **No \"local\" state**: Every state must be global, since a page refresh means any local variables will be re-declared the next time the page renders.\n\n## Demo framework\n\nSo, let's jump right out to some code samples. I hacked a simple library to render components to check how that could look like.\n\nI called it `RHReact`, which stands for `RHReact Hypertext React`. Very original, huh?\n\nThis is what a component looks like in RHReact:\n\n```php\n# /Components/MyComponent\n<?php\n\nnamespace Components;\n\nuse RHReact\\Component;\nuse RHReact\\State;\n\nclass MyComponent extends Component {\n\n    function __construct()\n    {\n        $this->state = new State([\n            'counter' => $_SESSION['counter'] ?? 0\n        ]);\n    }\n\n    function increment(): void\n    {\n        $_SESSION['counter']++;\n    }\n\n    function render(): void\n    {\n        ?>\n        <h1><?= $this->state->get('counter') ?></h1>\n\n        <a href=\"<?= $this->methodLink('increment') ?>\">\n            Increment number by one\n        </a>\n        <?php\n    }\n\n}\n```\n\nThis is how it looks like (in the recording I was also experimenting with state mutations using forms, but I won't cover that here)\n\n<blockquote class=\"twitter-tweet\"><p lang=\"und\" dir=\"ltr\"><a href=\"https://t.co/vy8mSxypPu\">pic.twitter.com/vy8mSxypPu</a></p>&mdash; Francisco Brusa (@FranCanoBr) <a href=\"https://twitter.com/FranCanoBr/status/1200614131134394369?ref_src=twsrc%5Etfw\">November 30, 2019</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nIn the back, the `$this->methodLink()` method prints a link that refreshes the page and contains information for the controller to know it has to execute certain logic.\n\nThe new page receives some params using a GET request that looks like this:\n\n`GET /?_c=MyComponent&_m=increment`\n\nA method could optionally accept arguments as well :)\n\nAfter the page is reloaded, `RHReact` looks for this query params and executes them. After that, it makes a redirect back to the original page (the redirect is needed for the same reason that in a traditional Controller-Based app, to \"clean\" the query params from the user's address bar, to prevent a page refresh to re-trigger the method).\n\n`RHReact` still doesn't support any kind of Component inheritance, nor something similar to React's hooks.\n\nIt's so experimental, it can't even be installed in a subfolder yet. Still, if you wanna use it to do experiments, you can [find the source code in GitHub](https://github.com/AeonFr/RHReact).\n\n"
}