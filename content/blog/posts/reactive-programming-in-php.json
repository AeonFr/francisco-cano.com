{
  "title": "Why use Single-File Components also in the Server (or Why I'm building \"React in PHP\")",
  "draft": true,
  "date": "2019-11-30T01:35:48.284Z",
  "body": "A component is an isolated module that can contain business logic, presentation logic and can accept arguments (props).\n\nIf a Component is written in a single file, and it doesn't have sub-components, it could be a standalone application by itself.\n\nReusing components is much easier than reusing the logic, views and models when they are separated in different files and entry-points in the application's structure.\n\nIf you wan't to reuse a component, you simply call it from another.\n\nSince each component has it's own Models, Views and c\nControllers (conveniently renames State, \"render function\" and Methods), reusing them is very easy, and it's also really easy to _reason_ about them.\n\n## PHP and the \"Component-Based Paradigm\"\n\n> Note: \"Component-Based\" is also used to describe a modular approach to build software. In this article, **Component** will refer exclusively to **an entity with State, Methods and the ability to render a View**.\n\nAfter doing some research, I couldn't find anything like the \"single-file components\" approach that frameworks like React and VueJS have that could be implemented using a server-side language.\n\nBut most importantly for me was understanding why I found that idea so desirable. Let's examine the different approaches a little bit...\n\n### \"Controller-Based\" vs. \"Component-Based\"\n\nTraditional PHP applications (let's think of a Laravel app, for example) have this flow:\n\n[![Traditional Controller Based App. Click to open in Google Docs.](/img/uploads/traditional-controller-based-applications.svg \"Click to open in Google Docs.\")](https://docs.google.com/drawings/d/1Uos0VjQ89bd3p_FkjzqoDL6gLCpkdtOhZ5A0LyErv_0/edit?usp=sharing \"Click to view in Google Docs\")\n\n1. Controllers handle everything from rendering views to processing events like form submissions.\n2. Views and controllers are in different folders. The same view can be rendered by different controllers with different data.\n3. The same controller can handle events from different views.\n\nThis architecture is fine until we have the same form in different views or we have more than one form, or action, in the same view. Then it can became a little bit difficult to reason about.\n\nThis is how a view with three forms and a search input could look like:\n\n[![Controller-Based App with three forms and a search/filter form.](/img/uploads/controller-based-app-with-three-forms-and-a-search_filter-form.svg)](https://docs.google.com/drawings/d/1_9zcFBMCkT11p9JutJnHKp18r_MLlqBqyHIH7wMlpJQ/edit?usp=sharing \"Click to view in Google Docs\")\n\n**What would happen if we wanted to use a view, like \"CreateUserForm\", in another view?**\n\nWhen using the form in multiple views, it creates the need to use dinamic redirect rules to keep the logic of the controller DRY.\n\nIt's not a big issue, but it's also something difficult to trace or reason about and adds complexity.\n\n**What other problems this approach has?**\n\nNote that in the example above, the event \"`searchForm`->`onSubmit`\", goes to the same controller as `UserGetIndexController`.\n\nIt's very common to have the logic to filter models in the same controller that renders the view where the controllers are shown.\n\nThis innocent violation of the Single Responsibilty Principle is mostly due to the fact that is very difficult to reason and mantain code in wich the same View is rendered by two different Controllers. Also it conviniently makes the filter params available in the route as GET params.\n\n### What if there was a better way?\n\nThis is the complex app above, but with a \"Component-Based\" approach:\n\n[![Complex App in Reactive Programming](/img/uploads/complex-app-in-reactive-programming.svg)](https://docs.google.com/drawings/d/1G3R-HFbfgzvnhTIKNWNq_vZMuEz-ODebQw1-VkEkcQ8/edit?usp=sharing \"Click to open in Google Draw\")\n\nIn the Component-Based app, each sub-component contains the logic to mutate the global state (the Database in this case, but it might as well be a Cookie, a Session variable, or Query Params). This logic is called **the component Method**.\n\nYou might have noticed some things in this approach: (note: I'm using the word \"Component\" with title case to differentiate it from \"controller\")\n\n* The architecture of the app is now radically more simple than before (a single controller is used)\n* Each individual Component is now reusable in other controllers, without adding redirections or any other kind of change in the controller itself.\n* The internal methods of the Component could be refactored to mutate the state in a different way, or show data differently, without altering the code of other Components, or controllers.\n* **Application's flow is easier to reason about**\n\n## How working in a Reactive Framework could look like in PHP\n\nIn a server-side language like PHP, a Reactive Framework would have to solve some extra challenges and limitations (or features, deppends on how you want to see it):\n\n1. **Imposible to use \"disposable\" state**: every state change must be persisted (session storage, database, cookies, query param, etc...) and wouldn't be \"rolled back\" when refreshing the page.\n2. **Each method consists of a page refresh**: Since the methods would actually be called using a POST or GET request, the page would need to be refreshed. Behind the scenes the framework would excecute the method and then redirect back to the original controller. I will explain this better below.\n3. **No \"local\" state**: Every state must be global, since a page refresh means any local variables will be re-declared the next time the page renders.\n\n## Demo framework\n\nSo, let's jump right out to some code samples. I hacked a simple library to render components to check how that could look like.\n\nI called it `RHReact`, which stands for `RHReact Hypertext React`. Very original, huh?\n\nThis is what a component looks like in RHReact:\n\n```php\n# /Components/MyComponent\n<?php\n\nnamespace Components;\n\nuse RHReact\\Component;\nuse RHReact\\State;\n\nclass MyComponent extends Component {\n\n    function __construct()\n    {\n        $this->state = new State([\n            'counter' => $_SESSION['counter'] ?? 0\n        ]);\n    }\n\n    function increment(): void\n    {\n        $_SESSION['counter']++;\n    }\n\n    function render(): void\n    {\n        ?>\n        <h1><?= $this->state->get('counter') ?></h1>\n\n        <a href=\"<?= $this->methodLink('increment') ?>\">\n            Increment number by one\n        </a>\n        <?php\n    }\n\n}\n```\n\nThe component is loaded in the page like this:\n\n```php\n#/index.php\n<?php\n\nsession_start();\n\nrequire \"vendor/autoload.php\";\n\n\\RHReact\\UI::boot(\\Components\\MyComponent::class);\n```\n\nThis is how it looks like (in the recording I was also experimenting with state mutations using forms, but I won't cover that here)\n\n<blockquote class=\"twitter-tweet\"><p lang=\"und\" dir=\"ltr\"><a href=\"https://t.co/vy8mSxypPu\">pic.twitter.com/vy8mSxypPu</a></p>&mdash; Francisco Brusa (@FranCanoBr) <a href=\"https://twitter.com/FranCanoBr/status/1200614131134394369?ref_src=twsrc%5Etfw\">November 30, 2019</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\nIn the back, the `$this->methodLink()` method prints a link that refreshes the page and contains information for the controller to know it has to execute certain logic.\n\nThe new page receives some params using a GET request that looks like this:\n\n`GET /?_c=MyComponent&_m=increment`\n\nA method could optionally accept arguments as well :)\n\nAfter the page is reloaded, `RHReact` looks for this query params and executes them. After that, it makes a redirect back to the original page (the redirect is needed for the same reason that in a traditional Controller-Based app, to \"clean\" the query params from the user's address bar, to prevent a page refresh to re-trigger the method).\n\n`RHReact` still doesn't support any kind of Component inheritance, nor something similar to React's hooks.\n\nIt's so experimental, it can't even be installed in a subfolder yet. Still, if you wanna use it to do experiments, you can [find the source code in GitHub](https://github.com/AeonFr/RHReact).\n\n## What's next?\n\nThe Reactive approach to programming still has to solve a lot of problems before proving itself useful in the server-side. Think of things like:\n\n* Middlewares\n* Error handling\n* Shared logic between components\n* Integration with existing frameworks (Laravel, Ruby on Rails, etc.)\n\nA Reactive framework for a server-side language would need to address this issues and prove itself better than a Controller-Based architecture.\n\nI will continue to develop `RHReact` (will possibly get a new name, though) and try to solve this issues and others that might come in the way."
}