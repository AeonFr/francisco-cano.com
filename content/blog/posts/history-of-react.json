{
  "draft": true,
  "date": "2020-02-05T23:18:09Z",
  "title": "History of React (from websites to web apps)",
  "body": "# History of React (and declarative UIs)\n\nA lot of the apps that we use everyday already existed back in 2008, but they didn’t look like they do today.\n\nFacebook, Twitter, Paypal… These apps were already in the market, but they were websites that felt a lot more static than today. Mobile apps and responsive design hadn’t taken off and users didn’t had the high expectations they have today.\n\nA lot have changed since. This is a story about how new programming paradigms allowed new kind of web experiences. It’s a story about React, but also about Angular, Vue, Ember, and many others.\n\n## From 2008 to the present\n\n2008 is approximately the time the precursor of the Ember framework started being developed.\n\nThe first iPhone had been launched a year prior, and new browsers were emerging: Safari, Chrome, Firefox.\n\nThis means on one side, users began having higher expectations regarding apps. Native apps provided a much better experience and the web was lagging behind.\n\nOn the other side, new browsers brought a wave of innovations that were long due. Internet Explorer had dominated the market in a period marked by lack of innovation. That era was starting to end. \n\nAround this time, an idea came together to a lot of people who’s pioneering work culminated in some of the ideas we will explore in this article.\n\nWe’re talking about the creators of Ember, Angular and React, three frameworks created between late 2008 and 2013. This frameworks have in common a philosophy that can be summarized with this extract retrieved from the [2013’s article “What is AngularJS?” (from the AngularJS docs)](https://docs.angularjs.org/guide/introduction):\n\n> AngularJS is built on the belief that declarative programming should be used to create user interfaces and connect software components, while imperative programming is better suited to defining an application's business logic.\n\nAlso around this time, a technical innovation allowed to popularize this ideas and make them fit nicely with the existing web technology of the DOM. Facebook’s (React) engineers and Ember.js engineers, approximately at the same time, invented the *virtual DOM* algorithm [quotation needed].\n\n!! image of virtual DOM as taken from the “whow to build your own react” article\n\n### Controversies\n\nWhen Ember.js first came along, it faced a lot of resistance.\n\nPeople were not necessarily against making websites feel like native apps. But it was too much of a change: the best practice so far was to avoid using JavaScript whenever possible, a language that was still considered unstable and “hacky”.\n\nReact also faced some controversy and backslash for it’s use of JSX, which was considered a breach in the “separation of concerns” principle, which a lot of people believe produces good code.\n\n> HTML is mainly used for organization of webpage content, CSS is used for definition of content presentation style, and JS defines how the content interacts and behaves with the user.\n>\n> - [Wikipedia, “Separation of concerns”](https://en.wikipedia.org/wiki/Separation_of_concerns#HTML,_CSS,_JavaScript)\n\nThe latest controversy relates to the use of “CSS-in-JS”, or the encapsulation of the CSS styles used by a _JS component_ within the component itself, through the use of JS.\n\nA lot of the adopters of these technologies believe the separation of HTML, JS and CSS is a “fake abstraction”, since any modern web app can’t really work without any of those.\n\n### Widespread adoption\n\nToday, React is so ubiquotous, you probably use it every single day, whether you know it or not.\n\nWe are using in websites, and, thanks to things like React Native and webviews, also in some native apps. Here’s a list of some of those apps:\n\n- Facebook (Web & App)\n- Instagram (Web & some parts of the App)\n- Whatsapp (Web)\n- Twitter (Web)\n- Spotify (Web)\n- Slack: Web & App (since their app is a “webview”)\n- Netflix: Web & App (hibrid)\n\n## The principles\n\n**Why is React’s usage so widespread?** React solves common issues developers face coding UIs, and does so in three ways:\n\n- Encapsulated components\n- Top-down data flow\n- Declarative rendering\n\n_List taken from [this blog post](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html) on the React Blog_\n\nWe will be examining each one of this items in detail.\n\n### Encapsulated components\n\nBarbara Liskov invented **abstract data types** in 1974, changing the software world forever[^1].\n\nThe concept of *modularization* is so ubiquitous nowadays for programmers, is hard to imagine someone had to define it.\n\nBarbara Liskov undestood that the API, the contract that the module offers, should not deppend on the implementation details of such program. A programmer should be able to refactor the implementation of a module without changing it’s API.\n\n> “What we desire from an abstraction is a mechanism which permits the expression of relevant details and the suppression of irrelevant details.”\n> — Programming With Abstract Data Types, Barvara Liskov\n\nLiskov’s research concluded in a programming language that is precursor of modern OOP languages.\n\n> “You could define abstract types with it, and then create instances of those objects. It had information hiding as a way to make programs easier to prove correct. It provided strong type checking, and many other techniques, that are so widespread today, that almost seem too basic to be talking about them.”[^1]\n\n[^1]: https://medium.com/a-computer-of-ones-own/barbara-liskov-inventor-of-abstract-data-types-9f8908fdcf86\n\n**Components are Abstract Data Types.**\n\nIn React you write your UI as a series of components, that are like the “lego bricks” of your application.\n\nThere wasn’t any abstraction before that allowed the proper **encapsulation** of a piece of HTML, JS and CSS within a web application.\n\nAnd the same way the adoption of modules changed the way we write applications, I think the adoption of components will forever change the way we write front-end applications.\n\nJust like with a traditional web module, the consumers of the components don’t need to understand how the component work, they only need to understand the API: the **properties** and **events** the component accepts. (We will dive into props and events soon).\n\n!! graphic: OOP object vs JS component\n\nThe mantainer of the component can change the way the HTML, JS or CSS works, and as long as public API (props and events) doesn’t change, all users can instantly update to the latest version without hassle.\n\nIn the “old world” of libraries like Bootstrap, you would _marry_ with the HTML structure given by such a library, and with certain classnames, and `data-` attributes. These can’t be changed by the library mantainers without introducing breaking changes.\n\nThis also means you don’t fully own your code: you can’t change the classnames provided by such libraries like Bootstrap, because they might break the JS. This means, for example your BEM classname convention can’t be fully propagated. The same goes with `data-` attributes and HTML structures.\n\n### Top-down data flow\n\nThe concept of top-down data flow refers to the way the components are organized in an app and communicate between each other.\n\nLet’s look at this React component (written in JSX):\n\n```jsx\nimport Select from './Select.js';\n\nlet select = <Select />\n```\n\nThis component behaves like a regular HTML5 select input. We need to pass it a list of options and _voilà_.\n\n```jsx\nlet select = <Select>\n\t<option value=\"1\">First option</option>\n</Select>\n```\n\nSince we’re making a JavaScript app, it would make more sense to populate the options using a JSON.\n\n```jsx\nvar options = [\n\t{ value: 1, title: 'First option' },\n\t// …\n];\n\nvar select = <Select options={options} />\n```\n\nWhat we just did is _we passed a **property**_ to our component.\n\nProperties can be objects, arrays, booleans, functions, classes, or any other JS data type.\n\nWe can pass a property that would add a search input to the component and alow us to search between all the options. (Of course, assuming the `Select` component supports this functionality).\n\n```jsx\nvar select = <Select\n\toptions={options}\n\thasSearch={true}\n/>\n```\n\nWe could also listen to events inside this component and act accordingly. Let’s say for example we want to know when the selected option changes to execute some logic:\n\n```jsx\nlet myFunction = event => { /* do something */ };\n\nvar select = <Select\n\toptions={options}\n\thasSearch={true}\n\tonChange={myFunction}\n/>\n```\n\n**This is top-down data flow in action**: components pass properties to their **childrens**, and send events to their **parents**.\n\nThe effect is an **application architecture** that follows the [dependency-inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle) (the letter “D” in “SOLID”). \n\nAny components only _depends_ on their children components, not on the parent. This ultimately guarantees a component can be **reused** in a pletora of contexts.\n\n### Declarative rendering\n\nDeclarative rendering, also known as _state-driven UIs_ or _pure UIs_, is the way in which components are writen in React.\n\nLet’s think of it with the typical example of a simple counter.\n\nUsing an *imperative* paradigm, we can articulate the program we want to write as: “every time the button is clicked, the counter increments”.\n\nWhereas using a *declarative* paradigm, we could say: “this counter shows the ammount of times the button was clicked”.\n\nComponents are *declarative* because we don’t write what steps are needed to perform an action. Instead, we *declare* what the system should look like, and let the language figure out the steps to get there.\n\nDeclarative Rendering is also refered to as **state-driven UIs**, and there’s an excelent explanation of why this caused a problem in the [“Metaphysics and JavaScript” presentation by Rich Harris](https://docs.google.com/presentation/d/1PUvpXMBEDS45rd0wHu6tF3j_8wmGC6cOLtOw2hzU-mw/edit#slide=id.p), the creator of Svelte.\n\n> Let’s say you want to build an app with six possible states — a, b, c, d, e and f. If you’re building a state driven app then that means you have to write six different views — it’s that simple.\n>\n> !! GIF of “state-driven UIs” slide goes here\n>\n> In the old event-driven world, it wasn’t like that. As well as worrying about creating the views corresponding to those states, you had to consider the transitions between states — from a to b, a to c, a to d and so on — but also from b back to a, from b to c… until you end up with a combinatorial explosion of code paths. Now imagine we added a seventh state, or an eighth… and if your app only has 8 possible states then I envy you.\n>\n> !! GIF of “state-driven UIs” gone south, slide goes here\n\n(It’s worth mentioning that this presentation by Rich Harris was  a critique to the React implementation of declarative rendered UIs, but that’s a topic for a different article).\n\n**Example**\n\nLet’s look at declarative rendering in action. This is the code for a fully functional React component. (There’s code related to how Node and React works that we won’t dive into).\n\n```jsx\nimport React, {useState} from 'react';\n\nexport default function Counter() {\n\tlet [count, setCount] = useState(0);\n\t\n\treturn (\n\t\t<div>\n\t\t\tCounter was clicked {count} time{count != 1 ? 's' : null}\n\t\t\t<button onClick={() => setCount(count + 1)}>\n\t\t\t\tIncrement 1\n\t\t\t</button>\n\t\t</div>\n\t);\n}\n```\n\n!! Link to the demo in codepen\n\n**Step by step**\n\nWe are importing the React library and exporting a `Counter` function. This function is our component.\n\nUsing a React feature called `state`, we declare a `count` variable that will contain our value for the counter, and a `setCount` function that will mutate the value of `count`.\n\nAfter that, we _declare_ how our component looks. In here, we show the value of count and add a callback to the button’s click event that will increment the value of count.\n\nCalling the `setCount` function will make the text update “automatically”.\n\n**Adding an input**\n\nNow let’s say we want to add an input that shows and sets the value of count. We need to actually add the `<input/>` element and some logic that makes it show the value of `count` and update it when the input’s value changes. This looks like this:\n\n```jsx\n\t// …\n\treturn (\n\t\t<div>\n\t\t\tCounter was clicked {count} time{count != 1 ? 's' : null}\n\t\t\t<button onClick={() => setCount(count + 1)}>\n\t\t\t\tIncrement 1\n\t\t\t</button>\n\t\t\t\n\t\t\t<!— Added this: —>\n\t\t\t<input\n\t\t\t\ttype=\"number\"\n\t\t\t\tvalue={count}\n\t\t\t\tonInput={event => setCount(event.target.value)}\n\t\t\t/>\n\t\t</div>\n\t);\n```\n\n!! codepen demo\n\nThis already works as expected: *clicking the button now updates both the text and the input’s value, and changing the input now updates the text*.\n\nIn the old jQuery world, adding this input would also have involved changing the behaviour of the `onClick` event for the button. The code that would update the text would be inside this event, but now here we would also need to update the input.\n\nThis is the problem of imperative UIs: we don’t only need to declare the components, we also need to be aware of how they can change over time, and how those changes affect other components. \n\nOr, as Rich Harris described it, we don’t only need to describe “a” and “b”, we also need to describe the transitions from “a” to “b”, and from “b” back to “a”. (And what if we wanted to add “c”?).\n\n## Conclusion\n\nThe three advantages of React, **declarative rendering**, **top-down data flow** and **encapsulated components** means we can write code that’s easier to reason about, mantain and reuse.\n\nOur “counter” component from the example above can be used to illustrate all of these principles.\n\nThanks to **component encapsulation**, we can call our `Counter` component multiple times and each one will keep it’s own unique value for `count`.\n\n```jsx\nexport default function CounterList () {\n\treturn (\n\t\t<div>\n\t\t\t<Counter/>\n\t\t\t<hr/>\n\t\t\t<Counter/>\n\t\t\t<hr/>\n\t\t\t<Counter/>\n\t\t</div>\n\t);\n};\n```\n\n!! codepen demo\n\nThanks to **top-down data flow**, we can pass a property to our counters to, for example, configure the initial value for `count`.\n\n```jsx\nexport default function CounterList () {\n\treturn (\n\t\t<div>\n\t\t\t<Counter/>\n\t\t\t<hr/>\n\t\t\t<Counter initialValue={10} />\n\t\t\t<hr/>\n\t\t\t<Counter initialValue={100} />\n\t\t</div>\n\t);\n};\n```\n\n!! codepen demo\n\n(I won’t explain in detail what changes the `Counter` component had, but notice I only changed two lines for this to work).\n\nAnd thanks to **declarative rendering**, we can add as many inputs, buttons or texts to show and edit the content of `Counter` without changing the code for the existing inputs/buttons/texts.\n\n### These advantages that React provides are the reason it’s so widly adopted nowadays\n\nThese ways to write UI code are crucial to make escalable and modern applications that look and feel like native apps.\nThey gave impulse to things like “single page applications” and “progressive web apps”.\n\nAnd just like it’s hard to imagine how code was written before “abstract data types” were invented, it might soon be difficult to imagine how to write frontend code _without_ applying this concepts."
}
